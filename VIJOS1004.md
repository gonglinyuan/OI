*这是一道很水的博弈论题目，难点反而在于对日期的处理*

###题目错误
**题目描述中的2001年11月4日实际应该是2006年11月4日。**虽然年份对结果并无影响，但这一疏漏对于某些正常程序还是十分致命的。

###算法
- 有人通过寻找规律得出了一个代码仅10行的算法。由于笔者的归纳能力不佳，于是使用了主流的递推法。这种方法在考场中还是比较容易想到的。
- 根据博弈论问题的一般套路，此题的状态转移方程还是很容易想到的。 **f[day]=!(f[NextDay]&&f[NextMonth])** 原理： *仅在可以转移到的状态都是必胜态时，该状态才是必败态，否则总有办法取胜* 。
- 同样，边界条件也很明了。 **f[LastDay]=false**。 因为题设是 *“谁先将日期变到2001.11.4谁就赢了”* 。

###日期处理
- 主要就是闰年处理，这对大家来说应该很容易，但也比较容易遗漏。
- 对于状态转移时超限日期的处理，也是十分头疼的事情。如果通过比较直接判断日期是否超限，代码将会十分繁杂。于是笔者将那些不可能达到的状态全部认为是必胜态，根据状态转移方程，这并不会影响结果。
- 千万要仔细看题目描述。如果当前日期是1月31日，就无法进行到下个月！

###标程

```cpp
#include <cstdio>
#include <cstring>

const int num[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
bool f[2500][15][35],p,q;
int yy,mm,dd,y,m,d,N;

int getnum(int y,int m) // 获取第y年m月的天数
{
    if (m==2&&y%4==0&&(y%100!=0||y%400==0))
        return num[2]+1;
    else
        return num[m];
}

bool nextmonth(int y,int m,int d) // 返回下一个月的状态，若超过限制，也返回true
{
    m++;
    if (m>12)
    {
        y++;
        m=1;
    }
    if (d>getnum(y,m)) // 如果不能变换到下一个月，返回true
        return true;
    else
        return f[y][m][d];
}

int main()
{
    y=2006; m=11; d=4; // 这里是题目的错误，实际应为2006年11月4日
    memset(f,true,sizeof(f)); // 赋成true可以让超过日期限制的状态全部返回true
    f[y][m][d]=false;
    p=false;
    while (d--) // 从2006年11月3日开始倒推
    {
        if (d<=0)
        {
            m--;
            if (m<=0)
            {
                y--;
                m=12;
            }
            d=getnum(y,m);
        } // 使当前日期合法
        q=nextmonth(y,m,d); // q记录的是下一个月的状态，如果超过限制则q=true
        f[y][m][d]=!(p&&q);
        p=f[y][m][d]; // p记录的是下一天的状态
        if (y==1900&&m==1&&d==1) break; // 如果到了1900年1月1日则推出循环
    }
    scanf("%d",&N);
    while (N--)
    {
        scanf("%d%d%d",&yy,&mm,&dd);
        printf(f[yy][mm][dd]?"YES\n":"NO\n");
    }
    return 0;
}

```
