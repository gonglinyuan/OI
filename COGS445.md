*经典DP+容斥原理*

###最长公共子序列的长度
经典的DP，方程如下：
> 第一种情况，若a[i]==b[j]， f[i][j]=f[i-1][j-1]+1;

> 第二种情况，若a[i]!=b[j]， f[i][j]=max(f[i-1][j],f[i][j-1])

十分简单的经典题目。

###求出方案数
- 同样是DP，设 *g[i][j]* 为 *a[1..i]* 和 *b[1..j]* 长度为 *f[i][j]* 的公共子序列方案数。 *g[i][j]* 可以与 *f[i][j]* 一起处理。统计方案数的原则是：从哪里转移过来的状态，就从哪里统计方案数目。

- 在前文所述的第一种情况中， *f[i][j]* 从 *f[i-1][j-1]* 转移得到，所以 *g[i][j]=g[i-1][j-1]* 。但这样太欠考虑了。如果 *f[i][j]==f[i-1][j]* ，那么 *f[i-1][j]* 的每个方案也可以在 *f[i][j]* 中实现，所以也要统计进去，即 *g[i][j]+=g[i-1][j]*。对于 *f[i][j-1]* 也同理。 

- 对于前文所述第二种情况， *f[i][j]* 从 *f[i-1][j]* 和 *f[i][j-1]* 中较大者转移得到，所以 *g[i][j]=g[i-1][j]* 或者 *g[i][j]=g[i][j-1]* 。但如果 *f[i-1][j]==f[i][j-1]* 呢？那么 *g[i][j]=g[i-1][j]+g[i][j-1]* ，可是当 *f[i-1][j]* 和 *f[i][j-1]* 都统计了 *f[i-1][j-1]* 的状态时（也就是说 *f[i][j]==f[i-1][j-1]* 的时候）会有重复计算的情况。根据容斥原理，要将那种 *g[i-1][j-1]* 减去。

- 边界处理： *g[0][i]=1* 且 *g[i][0]=1* 因为当 *f[i][j]==0* 时，要保证 *g[i][j]==1* 。答案就是 *g[n][m]* 。

###常数优化

上面的算法虽然是 *O(n^2 )* ，但是在 *n=5000* 而且评测机配置较落后的情况下是会TLE的，所以要常数优化。

1. 不要用cin和scanf，由于是读整行，所以可能用fgets更快，也可以逐字符读入。
2. 由于 *f[i][j]* 只与 *f[i][j-1]* 、 *f[i-1][j]* 以及 *f[i-1][j-1]* 有关，所以可以使用滚动数组（由于 *g[i][j]* 也一样），减少二维数组的寻址时间。
3. 不要在循环的判定条件上使用strlen函数，不然会退化成 *O(n^3 )* 。应该在读入之后就把字符串长度记下来。
4. 去掉不必要的取模。

###标程

```cpp
#include <cstdio>
#define P 100000000

int f[2][5010],g[2][5010],i,j,n,m,k;
char a[5010],b[5010],*p;

int main()
{
    freopen("lcs.in","r",stdin);
    freopen("lcs.out","w",stdout);
    p=a+1; while (*p<64) *p=getchar();
    while (*p>=64) *(++p)=getchar(); n=p-a-1;
    p=b+1; while (*p<64) *p=getchar();
    while (*p>=64) *(++p)=getchar(); m=p-b-1;
    g[0][0]=g[1][0]=1;
    for (i=0;i<=m;++i) g[0][i]=1;
    for (i=1;i<=n;++i)
        for (j=1;j<=m;++j)
        {
            k=i&1;
            if (a[i]==b[j])
            {
                f[k][j]=f[k^1][j-1]+1;
                g[k][j]=g[k^1][j-1];
                if (f[k][j]==f[k^1][j])
                    g[k][j]=(g[k][j]+g[k^1][j])%P;
                if (f[k][j]==f[k][j-1])
                    g[k][j]=(g[k][j]+g[k][j-1])%P;
            }
            else
            {
                if (f[k^1][j]>f[k][j-1])
                {
                    f[k][j]=f[k^1][j];
                    g[k][j]=g[k^1][j];
                }
                else if (f[k^1][j]<f[k][j-1])
                {
                    f[k][j]=f[k][j-1];
                    g[k][j]=g[k][j-1];
                }
                else
                {
                    f[k][j]=f[k^1][j];
                    g[k][j]=g[k^1][j]+g[k][j-1];
                    if (f[k^1][j-1]==f[k][j])
                        g[k][j]-=g[k^1][j-1];
                    g[k][j]=(g[k][j]+P)%P;
                }
            }
        }
    printf("%d\n%d\n",f[n&1][m],g[n&1][m]);
    fclose(stdin); fclose(stdout);
    return 0;
}

```
