*一道经典的最长（不）上升子序列题目，但第二问的贪心结论却有待证明*

###算法###
 - 第一问：求出序列中最长不上升子序列的长度，这十分显然。

 - 第二问：求出序列中 **最长上升子序列** 的长度，结论可能不是那么显然，下面我们将证明这个算法是正确的。

两问都可以通过 *单调栈+二分*  在 *O(n log n)*  的时间内搞定，这里不再赘述。

###第二问算法的正确性证明###
这涉及到组合数学的 *Dilworth定理* ，由于原定理的语言过于深奥，这里先将它转化为更加简单的表述：
>  对于一个有限数列 *S*  ，它的最少 *不上升子序列* 划分数 *p* 等于它的 *最长上升子序列* 长度 *r* 。

首先证明 *p>=r* ：
> 因为 对于最长上升子序列中的每两个元素 *b[i]* 、 *b[j]* ，都有 *b[i]<b[j]* 。

> 假设它们属于同一个不上升子序列，则有 *b[i]>=b[j]* 。

> 推出矛盾，所以最长上升子序列中每两个元素必不属于同一个不上升子序列，即 *p>=r* 。

然后证明 *p<=r* ：
> 先定义 **极小元** 的概念：如果 *a* 属于有限数列 *S* ，而且每一个在 *a* 之前的元素 *x* 都满足 *x>=a* ，那么 *a* 就是数列 *S* 中的极小元。显然，同一个有限数列中的所有极小元组成的序列一定是不上升子序列。

> 设 *X1=S* 。将 *X1* 中所有极小元组成的集合 *Z1* 删去，得到 *X2* 。然后 *X2* 中所有极小元组成集合 *Z2* 。

> 注意到对于 *Z2* 中的每个元素 *a2* 都存在 *a1* （ *a1 属于 Z1* ），满足 *a1<a2* 。（否则 *a2* 一定在第一次就已经被加入 *Z1* 了）

> 再将 *Z2* 从 *X2* 中删除、得到 *X3* …… 以此类推。

> 假设 *Xk* 是最后一个非空集合，那么从 *X1* 、 *X2* 、 *X3* …… *Xk* 中分别取出元素 *a1* 、 *a2* 、 *a3* …… *ak* ，一定能组成一个上升子序列。

> 因为最长不上升子序列长度为 *r* ，所以一定有 *r>=k* 。因为每个 *Xi* 都是不上升子序列，所以 *k>=p* 。即 *p<=r* 。

综上所述，p=r，原命题得证，第二问算法正确。

###标程###

```cpp
#include <cstdio>

int s1[1010],s2[1010],l,r,m,x;

int main()
{
	freopen("missile.in","r",stdin);
	freopen("missile.out","w",stdout);
	while (scanf("%d",&x)==1)
	{
		if (x<=s1[s1[0]]||!s1[0]) s1[++s1[0]]=x;
		else
		{
			l=1; r=s1[0];
			while (l<r)
			{
				m=l+(r-l)/2;
				if (x<=s1[m]) l=m+1;
				else r=m;
			}
			s1[l]=x;
		}
		if (x>s2[s2[0]]) s2[++s2[0]]=x;
		else
		{
			l=1; r=s2[0];
			while (l<r)
			{
				m=l+(r-l)/2;
				if (x>s2[m]) l=m+1;
				else r=m;
			}
			s2[l]=x;
		}
	}
	printf("%d\n%d\n",s1[0],s2[0]);
	fclose(stdin); fclose(stdout);
	return 0;
}

```
