*一道斜率优化DP* 

###朴素的算法###
首先对所有的 *(x[i],y[i])* ，以 *x[i]* 为第一关键字、 *y[i]* 为第二关键字从大到小排序。由题意，若 *x[i]<=x[j]* 且 *y[i]<=y[j]* ，说明矩形i被包括在矩形j内，购买满足矩形j大小的土地时矩形i也被包括在内了，所以矩形i可以删除。因为矩形已经按降序排好了，所以可以在 *O(n)* 的时间内将要删除的矩形删除。

那么，剩下的所有 *(x[i],y[i])* 中，对任意 *x[i]<=x[j]* 都不存在 *y[i]<=y[j]* 。而原本我们是按 *x[i]* 的降序排序的，所以保证了对于任意 *x[i]<=x[j]* 都有 *i>j* 。所以，就有对任意的 *i>j* 都满足 *y[i]>y[j]* ——也就是说， *y[i]* 是按照升序排列的。

原问题是要讲n个矩形划分为若干个子集。但是将所有矩形经过上述处理以后，满足 *x[i]* 降序、 *y[i]* 升序，所以最优条件下所划分出的子集中所有元素必定相邻，证明如下：
> 假设子集S是[l,r]上不连续的一段且S中最小元素是l，最大元素是r。

> 因为 *x[i]* 降序、 *y[i]* 升序，所以：

> *x[l]=max{x[i]}* 且 *y[r]=max{y[i]}* 对任意满足l<=i<=r的i恒成立。

> 因此上述结论对于任意满足i属于S的i恒成立。

> 所以 *cost(S)=x[l]*y[r]* 且*cost([l,r])=x[l]*y[r]* 

> 又因为S是 *[l,r]* 的真子集，而 *cost(S)=cost([l,r])* ，所以当S不连续时结果必然不是最优的。

原问题就可以用动态规划来解决，设 *f[i]* 表示从1到i的所有矩形的最小代价，就有：
> f[i]=min{f[j]+x[j+1]*y[i]}

这个状态转移方程表示要将 *[j+1,i]* 的所有矩形合并；有了上面的证明，应该很好理解。

然而，这个朴素算法的复杂度是 *O(n^2 )* 的，还需要进一步优化。

###斜率性质###
观察DP方程：
> f[i]=min{f[j]+x[j+1]*y[i]}

为了美观和简洁，我们将 *x[i]* 数组往前提一位，那就变成了：
> f[i]=min{f[j]+x[j]*y[i]}

如果状态转移方程可以表示为 *f[i]=f[j]+g[j]* 的形式，且g[j]只与j本身有关，那么通常可以用单调队列优化DP。可是这里的 *x[j]*y[i]* 与i和j都有关系，所以要想其他办法。

考虑计算 *f[i]* 时要考虑决策 *f[j]* 和 *f[k]* ，且j<k。如果j比k更优，那么：
> f[j]+x[j]*y[i]<f[k]+x[k]*y[i]

> 即 (f[k]-f[j])/(x[j]-x[k])>y[i]

如果把 *(x[j],f[j])* 和 *(x[k],f[k])* 看成平面坐标系中的点，那么 *(f[k]-f[j])/(x[j]-x[k])* 就代表这两点连线的斜率了。当斜率大于 *y[i]* 时，说明j比k更优。

为了方便起见用 *g[j,k]* 表示 *(f[k]-f[j])/(x[j]-x[k])* ，即k和j连线的斜率。考虑 *a<b<c<i* 且 *g[a,b]>g[b,c]* 的情况。若 *g[a,b]>=y[i]* ，则a比b优或者a与b一样优；若 *g[a,b]<y[i]* ，虽然b比a优，但同样 *g[b,c]<y[i]* ，c比b更优。所以无论怎样，b总不会是最优的，就可以把b从决策点中删去。

也就是说，计算 *f[i]* 时对于所有决策点 *(x[j],f[j])* 连成的折线，对任意的 *a<b<c<i* 都必有 *g[a,b]<=g[b,c]* ，因此这条折线上每条线段的斜率单调递增，即折线构成一个下凸壳。

###斜率队列优化DP###
我们用一个斜率队列维护可行的决策点集合。

决策时，从队首开始。设a,b依次是队列左端元素，如果 *g(a,b)<y[i]* ，则b优于a，又因为 *y[i]* 单调递增，所以a不再可能成为最优的决策，因此a从队首出队。不断将元素出队，直到 *g(a,b)>=i* 为止。然后队首元素就是对于 *f[i]* 的最优决策点。

决策之后，要将i入队。设a,b分别是原来队列右端元素，由于要维护下凸壳，所以要将队尾元素不断出队，直到 *g[a,b]<=g[b,i]* 为止。然后i从队尾入队。

###标程###

```cpp
#include <cstdio>
#include <climits>
#include <algorithm>
using namespace std;

struct rect
{
	long long x,y;
	bool operator<(const rect &B)const
	{return x>B.x||(x==B.x&&y>B.y);}
}a[50010];

int n,i,j,q[50010],l,r;
long long f[50010],x[50010],y[50010];
bool del[50010];

int main()
{
	freopen("acquire.in","r",stdin);
	freopen("acquire.out","w",stdout);
	scanf("%d",&n);
	for (i=1;i<=n;++i) scanf("%lld%lld",&a[i].x,&a[i].y);
	sort(a+1,a+n+1);
	for (i=2;i<=n;++i)
		if (a[i-1].y>=a[i].y)
		{
			del[i]=true;
			a[i].y=a[i-1].y;
		}
	for (i=1,j=1;i<=n;++i)
		if (!del[i])
		{
			x[j-1]=a[i].x;
			y[j]=a[i].y;
			++j;
		}
	n=j-1;
	q[l=r=1]=0;
	for (i=1;i<=n;++i)
	{
		while (r-l>0&&f[q[l+1]]-f[q[l]]<y[i]*(x[q[l]]-x[q[l+1]])) ++l;
		f[i]=f[q[l]]+x[q[l]]*y[i];
		while (r-l>0&&(f[q[r]]-f[q[r-1]])*(x[q[r]]-x[i])>(f[i]-f[q[r]])*(x[q[r-1]]-x[q[r]])) --r;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	fclose(stdin); fclose(stdout);
	return 0;
}

```
