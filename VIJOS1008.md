*此题主要考验置换群的知识，具有一定难度*

###置换群
在理解题意所述的调整方式中，要注意实际上就是把M个在错误位置上的人移动到正确的位置上，所以代价就是M。因为如果有一个人不在正确的位置上，那么他正确的位置上的人也一定不在正确的位置上（否则无解），每一个不在位置上的人组成的一个环就是一个置换群，置换群的大小就是把这个置换群中元素排列有序的最少相邻交换次数，也就是代价M。

###环的处理
- 但是题中的人排成一个环。朴素的处理方法是将环正反旋转N次，每次都做一遍，求出最小的M。但这样的时间复杂度高达 *O(n^2 )* ，只能过30%的数据，不符合要求。
- 由于不管怎么转，任意两个人之间的相对位置都不会改变，所以想到做差。

>        1 5 3 2 4 
>     -  1 2 3 4 5
>     ------------ 
>        0 3 0 3 4

- 这表示序列1,5,3,2,4不转动时1,3两个人在原来的位置上，转动3个位置后5和2两个人在原来的位置上，转动4个位置后只有4一个人会在原来的位置上。这就是说，1,5,3,2,4与1,2,3,4,5在旋转后最多有2个位置上的人编号相同，即最少有3个位置上的人编号不相同。
- 由于本题的环以1为基准左右翻转后与原环等价，所以需要翻转后再做一次，不然只有70分。

###标程

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

int n,i,j,c[2][50010],a[50010],b[50010],d[50010],s[50010],ans;
bool vis[50010];

void noSolution()
{
    printf("-1\n");
    exit(0);
}

int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d%d",&c[0][i],&c[1][i]);
    a[1]=1; vis[1]=true;
    for (i=1;i<n;i++)
    {
        if (!vis[c[0][a[i]]])
        {
            a[i+1]=c[0][a[i]];
            vis[a[i+1]]=true;
        }
        else if (!vis[c[1][a[i]]])
        {
            a[i+1]=c[1][a[i]];
            vis[a[i+1]]=true;
        }
        else
            noSolution();
    }
    if (!(c[0][a[n]]==a[n-1]&&c[1][a[n]]==a[1]||c[1][a[n]]==a[n-1]&&c[0][a[n]]==a[1]))
        noSolution();
    for (i=1;i<=n;i++) b[i]=i;
    for (i=1;i<=n;i++)
    {
        d[i]=a[i]-b[i];
        if (d[i]<0) d[i]+=n;
    }
    memset(s,0,sizeof(s));
    for (i=1;i<=n;i++) s[d[i]]++;
    for (i=0;i<n;i++)
        ans=s[i]>ans?s[i]:ans;
    for (i=2,j=n;i<j;i++,j--)
    {
        int t=a[i]; a[i]=a[j]; a[j]=t;
    }
    for (i=1;i<=n;i++)
    {
        d[i]=a[i]-b[i];
        if (d[i]<0) d[i]+=n;
    }
    memset(s,0,sizeof(s));
    for (i=1;i<=n;i++) s[d[i]]++;
    for (i=0;i<n;i++)
        ans=s[i]>ans?s[i]:ans;
    printf("%d\n",n-ans);
    return 0;
}

```
