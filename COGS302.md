*背包DP+容斥原理* 

###当只有一种物品有数量限制的情况
先对所有物品做一遍朴素的完全背包，复杂度为 *O(n*m^2 )* ，状态转移方程：
> g[i][j]=sum{f[i-1][j-k*c[i]]} , j-k*c[i]>=0

最终答案就是g[n][m]了。

假设只有最后一件物品（即第n件物品）有数量限制，那么对于最后一件物品，状态转移方程为：
> f[n][j]=sum{f[i-1][j-k*c[i]]} , j-k*c[i]>=0且k<=d[i]

由于我们只需要知道最终答案f[n][m]，所以容易得到：
> f[n][m] = sum{f[n-1][m-k*c[n]]} , m-k*c[n]>=0且k<=d[n]

> = g[n][m]-g[n][m-(d[i]+1)*c[i]]

接下来我们要进行一些优化。把g[i][j]优化到一维，就变成了 *O(n*m)* 的完全背包：
> g[j]=g[j]+g[j-c[i]] , j>=c[i]

那么相应的：
> f[n][m]=g[m]-g[m-(d[n]+1)*c[n]]

不论处理g数组时物品顺序如何，最终的g数组的值都是一样的。因此对于所有的i（不只是 *i==n* 的情况），上式都是成立的。

###当有两种物品有数量限制的情况
假设有1和2两种物品。我们考虑上面得出的如下表达式的意义：
> g[m]-g[m-(d[1]+1)*c[1]]

可以这样理解：*g[m]* 是所有情况的数目，那么 *g[m-(d[1]+1)*c[1]]* 就表示当第一种物品数目超过 *d[1]* 时的情况数目。由于物品2也有数量限制，那么 *g[m-(d[2]+1)*c[2]]* 就是第二种物品超过 *d[2]* 时的情况数目。

但如果我们简单地用总情况数目减去那两种情况的方案数，那么当物品1和物品2都超过数量限制时的情况就被减了两遍，因此我们就要重新加上这种情况，也就是 *g[m-(d[1]+1)*c[1]-(d[2]+1)*c[2]]* 。就可以算出当两种物品都有数量限制时的情况数目了：
> ans=g[m]-g[m-(d[1]+1)*c[1]]-g[m-(d[2]+1)*c[2]]+g[m-(d[1]+1)*c[1]-(d[2]+1)*c[2]]

###用容斥原理处理物品数目更多的情况
同理，利用容斥原理，我们把两种物品的情况可以推广到三种物品，甚至四种物品。假设 *{x1,x2,x3}* 表示物品x1、物品x2和物品x3都超过数量限制时的情况数目，那么可以得到：
> ans=g[m] - {1} - {2} - {3} - {4} + {1,2} + {1,3} + {1,4} + {2,3} + {2,4} + {3,4} - {1,2,3} - {1,2,4} - {1,3,4} - {2,3,4} + {1,2,3,4}

因此对于原问题，只要先用完全背包处理g数组，然后对于每个询问用容斥原理统计答案即可，时间复杂度 *O(n*m+q*2^n )* ，完全可以通过 *n=4,m=100000,q=1000* 的数据。

###标程

```cpp
#include <cstdio>

int c[5],d[5],i,n,m;
long long f[100010],ans;

long long F(int k) {return k>=0?f[k]:0;}
int C(int k) {return (d[k]+1)*c[k];}

int main()
{
    scanf("%d%d%d%d%d",c+1,c+2,c+3,c+4,&n);
    f[0]=1;
    for (i=c[1];i<=100000;++i) f[i]+=f[i-c[1]];
    for (i=c[2];i<=100000;++i) f[i]+=f[i-c[2]];
    for (i=c[3];i<=100000;++i) f[i]+=f[i-c[3]];
    for (i=c[4];i<=100000;++i) f[i]+=f[i-c[4]];
    while (n--)
    {
        scanf("%d%d%d%d%d",d+1,d+2,d+3,d+4,&m);
        ans=f[m];
        ans-=F(m-C(1)); ans-=F(m-C(2));
        ans-=F(m-C(3)); ans-=F(m-C(4));
        ans+=F(m-C(1)-C(2)); ans+=F(m-C(1)-C(3));
        ans+=F(m-C(1)-C(4)); ans+=F(m-C(2)-C(3));
        ans+=F(m-C(2)-C(4)); ans+=F(m-C(3)-C(4));
        ans-=F(m-C(1)-C(2)-C(3));
        ans-=F(m-C(1)-C(2)-C(4));
        ans-=F(m-C(1)-C(3)-C(4));
        ans-=F(m-C(2)-C(3)-C(4));
        ans+=F(m-C(1)-C(2)-C(3)-C(4));
        printf("%lld\n",ans);
    }
    return 0;
}

```
