###转化为图论模型###
假设 *p[i]==x* ，我们就要把x换到 *p[x]* 位置。因为q是一个0到 *n-2* 的排列，所以每两个相邻的数能且仅能被交换一次。因此，我们必须先把x从 *p[i]* 到 *p[x]* 一个一个地换过去；假设 *i<x* ，那么我们必须先交换 *p[i]* 与 *p[i+1]* ，然后交换 *p[i+1]* 与 *p[i+2]* ……最后交换 *p[x-1]* 与 *p[x]* 。（当 *i>x* 时同理）这时一种关于“时间先后“的关系，因此可以用拓扑图的模型来解决。

把 *p[i]* 与 *p[i+1]* 的交换看作节点i。如果 *p[i]* 与 *p[i+1]* 的交换必须在 *p[j]* 与 *p[j+1]* 的交换之前，那么就要连一条从i到j的有向边……最后连成了一个有向无环图。我们只要求出拓扑序的方案数，就是答案了。

###计算方案数###
显然，上面得出的有向无环图中每条边连接的节点必定是序号相邻的，所以该图就是一个链表。所以方案数就可以使用DP来计算了。

设 *f[i][j]* 为节点0到节点i中，节点i在拓扑序中的排名是 *j+1* 时的方案数。初始状态就是 *f[0][0]=1* 。

对于每个i：如果有一条从 *节点i-1* 到 *节点i* 的边，说明 *节点i-1* 在 *节点i* 之前，那么就要统计 *节点i-1* 在位置j之前的情况总数，因此 *f[i][j]=sum{f[i-1][0~j-1]}* ；同理， 如果有一条从 *节点i-1* 到 *节点i* 的边， *f[i][j]=sum{f[i-1][j~i-1]}* 。

最终答案就是拓扑序的总数，也就是 *sum{f[n-2][0~n-1]}* 。

###标程###

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define P 1000000007

int n,i,j,k,x,ans,f[100][100],deg[100];
bool g[100][100],flag;

int main()
{
	scanf("%d",&n);
	for (i=0;i<n;++i)
	{
		scanf("%d",&x);
		if (x<i)
			for (j=i-1;j>x;--j)
			{++deg[j-1]; g[j][j-1]=1;}
		else if (x>i)
			for (j=i;j<x-1;++j)
			{++deg[j+1]; g[j][j+1]=1;}
	}
	for (i=0;i<n-1;++i) flag=flag||(!deg[i]);
	if (!flag)
	{
		printf("0\n");
		return 0;
	}
	f[0][0]=1;
	for (i=1;i<n-1;++i)
		for (j=0;j<=i;++j)
			if (g[i-1][i])
				for (k=0;k<j;++k)
					f[i][j]=(f[i][j]+f[i-1][k])%P;
			else if (g[i][i-1])
				for (k=j;k<i;++k)
					f[i][j]=(f[i][j]+f[i-1][k])%P;
	for (i=0;i<n-1;++i) ans=(ans+f[n-2][i])%P;
	printf("%d\n",ans);
	return 0;
}

```
