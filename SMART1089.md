*这是一道十分经典的题目，有许多要注意的地方，也有许多种不同的方法*

###方法一
这也是一种比较容易想到的方法。设 f[i][0] 为长度为i，末尾为0的K进制数的个数， f[i][1] 为长度为i，末尾不为0的K进制数的个数。
易得:

- f[i][0]=f[i-1][1] （一个末位不为0的K进制数后加0）
- f[i][1]=(f[i-1][0]+f[i-1][1])*(K-1) （在任意一个长度为i-1的K进制数后加任意一个非0数码）

理想时间复杂度为 *O(n)*

###方法二
如果反其道而行之，可能会有一种更加简单的方法。方法一是将数位往数字后面加，如果把数码加在数字前面，又会怎么样呢？设 f[i] 为长度为i的K进制数的个数，则

- f[i]=(f[i-1]+f[i-2])*(K-1) 
- （一个长度为i-1的K进制数前面加上任意一个非零数码+一个长度为i-2的K进制数前面加上任意一个非零数码和一个0，即 *f[i-1]乘以(K-1)* 加上*f[i-2]乘以(K-1)*）

理想时间复杂度为 *O(n)*

###高精度
如果真的这么简单，那此题就沦为送分题了。然而不难发现，当数据规模很大时，答案规模远远超过long long的范围。所以此题要用高精度。而且一般的高精度还不够，而且必须压位。
压位高精度数输出的时候，如果要输出4位，而且前面补零，要用到printf("%04d",n);

###标程

```cpp
#include <cstdio>
#include <cstring>

int n,k,i;

struct number
{
    int a[1000],n;
    void mov(number B)
    {
        memcpy(a,B.a,sizeof(a));
        n=B.n;
    }
    void add(number B)
    {
        int i,t=0;
        for (i=0;i<=n;i++)
        {
            a[i]+=B.a[i]+t;
            t=a[i]/10000;
            a[i]%=10000;
        }
        while (t)
        {
            a[++n]=t;
            t=a[i]/10000;
            a[i]%=10000;
        }
    }
    void mul(int x)
    {
        int i,t=0;
        for (i=0;i<=n;i++)
        {
            a[i]=a[i]*x+t;
            t=a[i]/10000;
            a[i]%=10000;
        }
        while (t)
        {
            a[++n]=t;
            t=a[i]/10000;
            a[i]%=10000;
        }
    }
    void out()
    {
        int i;
        printf("%d",a[n]);
        for (i=n-1;i>=0;i--)
            printf("%04d",a[i]);
        printf("\n");
    }
};

number f[2000];

int main()
{
    scanf("%d%d",&n,&k);
    f[0].a[0]=1;
    f[1].a[0]=1; f[1].mul(k-1);
    for (i=2;i<=n;i++)
    {
        f[i].mov(f[i-1]);
        f[i].add(f[i-2]);
        f[i].mul(k-1);
    }
    f[n].out();
}

```

###知识点
- printf前方补零
- 高精度压位