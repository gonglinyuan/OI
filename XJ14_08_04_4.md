*一道模拟题，考验组合数的运用*

###任意元素间隔至少K个元素的组合数
 - 先考虑一个子问题。有M个位置，将N个物品放入N个位置中，要求每两个物品中间至少间隔K个位置，应该怎么计算呢？
 - N个物品中，有N-1对相邻的物品，每一对相邻的物品中有K个位置是不能选的，因此对于所有物品，就只剩下了 *M-(N-1)*K* 个位置可选，因此答案就是 *C(M-(N-1)*K,N)* 。

###算法
 - 那么在原问题中，我们需要知道：直线上一共有N+1个位置要种K颗树，两棵树之间相隔D-1个位置，而且首尾两个位置必须种树（否则会导致方案重复），有多少种方案。套用前面的公式和思路，可以算出答案：  **C(N-1-(K-1)*(D-1),K-2)**  。
 - 枚举起点到终点的向量 *(i,j)* ，可以很容易算出这条向量有多少个整点，并且可以求出D的距离对应向量上需要间隔的整点数目。然后就可以用前文所述的方法求出方案数了。不过由于我们只枚举了斜向上的向量，所以统计答案时还得乘以2。
 - 为了简化计算，我们只需枚举gcd(i,j)==1的向量。然后扩展它的长度即可。
 - 对于水平或竖直的向量就更简单了，直接用组合数求解然后乘上可能的起点数目即可。

###标程

```cpp
#include <cstdio>
#include <cmath>
#define P 1000000000LL
#define C(x,y) (((x)<0||(y)<0)?0:c[x][y])

long long gcd(long long a,long long b) {return b?gcd(b,a%b):a;}
long long K,N,M,D,c[1510][1510],i,j,ans,L,x,y,z;

int main()
{
	scanf("%lld%lld%lld%lld",&K,&N,&M,&D);
	c[0][0]=1;
	for (i=1;i<=1500;++i)
	{
		c[i][0]=1;
		for (j=1;j<=1500;++j)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%P;
	}
	for (i=1;i<=N;++i)
		ans=(ans+(N-i+1)*(M+1)*C(i-1-(K-1)*(D-1),K-2))%P;
	for (i=1;i<=M;++i)
		ans=(ans+(M-i+1)*(N+1)*C(i-1-(K-1)*(D-1),K-2))%P;
	for (i=1;i<=N;++i)
		for (j=1;j<=M;++j)
		{
			if (gcd(i,j)>1) continue;
			L=(long long)ceil(D/sqrt(i*i+j*j));
			for (x=i,y=j,z=1;x<=N&&y<=M;x+=i,y+=j,++z)
				ans=(ans+2*(N-x+1)*(M-y+1)*C(z-1-(K-1)*(L-1),K-2))%P;
		}
	printf("%lld\n",ans);
	return 0;
}

```
