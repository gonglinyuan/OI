*这道题目需要根据数据的不同特性编写不同的算法，思维含量很高。*

###算法概述###
这道题目的数据范围是 *nm<=100000* ，因此我们需要根据m和n的不同特性编写相应的算法。当n较小时，我们很容易就可以想到一个 *O(mn^2)* 的暴力；当m较小时，我们可以想到一个 *O(9^m)* 的暴力。但是这显然无法通过全部数据，虽然只差了一点。接下来我们有两条路：我们可以对字符串进行压位，以加快运算速度，这样可以勉强AC；我们还可以用状压DP来处理m较小的情况，使它的复杂度大大降低。这里我们选用第二种思路，也是出题人的思路。

###n较小的情况###
这种情况下，我们只要读入所有的字符串，然后枚举每两个字符串一个一个字符进行比较即可。

注意到由于字符串长度不定，因此难以用二维字符数组全部存储下来。如果用STL的string，那么字符串过大的长度可能会导致超时。因此我们可以用一维字符数组来模拟二维数组，比如原本的 *s[i][j]* 就可以用 *s[i*m+j]* 来代替，这样就可以巧妙地存下全部的字符串了。

###m较小的情况###
状态表示：既然是统计个数的问题，那么很容易想到DP。m就是字符串的长度，由于长度较小，所以可以把整个字符串压位作为状态。字符串类型的DP基本都是逐位进行的，因此可以把当前位数作为状态。根据题意，“相似度”也要作为状态……因此我们就有了这样的思路：设状态 *f[i][S][j]* 表示对于字符串S，从第0位到第i-1位，在所有读入的字符串中和它有j个字符不同的字符串有几个。

初始状态：对于所有读入的字符串S0，我们记录下它出现的次数 *c[S0]* ，初始状态就是 *f[0][S0][0]=c[S0]* 。

状态转移：如果按照常规的倒推思路可能比较复杂，因此我们考虑递推，即考虑每个状态对它后面状态的影响。对于每个状态 *f[i][S][j]* ，我们枚举第i位的取值ch。如果ch与S的第i位相同，那么说明当i加上1与S不同的字符串和原来一样，因此要把当前状态的方案数累加到 *f[i+1][S][j]* 中；如果ch与S的第i位不同，假设将S的第i位替换成ch之后形成的字符串为S‘，那么说明S’的第0位到第i位形成的子串与S的第0位到第i位形成的子串多出一个不同的字符，因此要把当前状态的方案数累加到 *f[i+1][S'][j+1]* 中。

答案统计：DP的最终状态 *f[m][S][k]* 代表在读入的字符串中与S相似度为 *m-k* 的字符串有多少个，答案要求求出相似度为k的字符串有多少对，所以只要输出 *sum{f[m][S][m-k]×c[S]}* 即可。

优化空间复杂度：状态数目一共有 *m^2 × 3^m*  个，当m等于11时就难以存储了，这还不够优秀。注意到把i作为最外层状态时，任意 *f[i][...]* 都只与 *f[i-1][...]* 有关，因此可以使用滚动数组，这样完全可以存下 *m<=12* 的状态。

###算法分配###
> 算法一  时间复杂度：O(mn^2) 空间复杂度：O(mn)

> 算法二  时间复杂度：O(m^2×3^m) 空间复杂度：O(m×3^m)

因此我们选择 *m=12* 作为分界点。当 *m>12* 时选用算法一，当 *m<=12* 时选用算法二。两种算法实现时都要注意常数，防止被卡。

###标程###

```cpp
#include <cstdio>
#include <cstring>
#define A(S,k) (S/P3[k]%3)
#define M(S,k,ch) (S-A(S,k)*P3[k]+ch*P3[k])

const int P3[]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441};

int n,m;
long long c[531441],f[2][531441][20],s[150000],a[150000];

int getStr()
{
	int ret=0; char ch=getchar();
	while (ch<=32) ch=getchar();
	while (ch>32)
	{
		ret=ret*3+ch-'x';
		ch=getchar();
	}
	return ret;
}

int main()
{
	scanf("%d%d",&n,&m);
	if (m<=12)
	{
		int i,S,M=P3[m],j,ch; long long ans;
		for (i=0;i<n;++i) ++c[getStr()];
		for (S=0;S<M;++S) f[0][S][0]=c[S];
		memcpy(f[1],f[0],sizeof(f[1]));
		for (i=0;i<m;++i)
		{
			for (S=0;S<M;++S)
				for (j=0;j<=i;++j)
					for (ch=0;ch<3;++ch)
						if (ch!=A(S,i))
							f[!(i&1)][M(S,i,ch)][j+1]+=f[i&1][S][j];
			memcpy(f[i&1],f[!(i&1)],sizeof(f[i&1]));
		}
		for (j=0;j<=m;++j)
		{
			ans=0LL;
			for (S=0;S<M;++S) ans+=f[m&1][S][m-j]*c[S];
			if (j==m) ans-=n;
			printf("%lld\n",ans>>1);
		}
	}
	else
	{
		int i,j,k; char ch;
		for (i=0;i<n*m;++i)
		{
			ch=getchar();
			while (ch<=32) ch=getchar();
			s[i]=ch;
		}
		for (i=1;i<n;++i)
			for (j=0;j<i;++j)
			{
				long long sim=0;
				for (k=0;k<m;++k)
					sim+=(s[i*m+k]==s[j*m+k]);
				++a[sim];
			}
		for (i=0;i<=m;++i) printf("%lld\n",a[i]);
	}
	return 0;
}

```
